#!/usr/bin/stap
#
# blockio_lrq_atency_8kread.stp
#
# This is a SystemTap script to gather block I/O latency from the Linux kernel block I/O interface
# and print I/O latency histograms to be consumed by PyLatencyMap for heatmap visualization
#
# By Luca.Canali@cern.ch, March 2015
#
# This script is based on original ideas of biolatency-nd.stp of systemtap-lwtools
# by Brendan Gregg 
#
# Note the use of kernel.trace("block_rq_issue") and kernel.trace("block_rq_complete") instead of 
# ioblock.request and ioblock_end, this allow the probe to work without the need to have kernel debug info. 
#


global latencyTimes, requestTime

global IO_size = 8192    # this will be used as a filter: target 8KB operations for Oracle single-block I/O investigations
global IO_operation = 0  # this will be used as a filter: only consider read operations, i.e. bit N.1 of bi_rw == 0


probe kernel.trace("block_rq_issue") {
   # only collect info if operation type and size match requirements  
   # only consider the first bio, note: this is an approximation
   if ($rq->bio) {                   # discard entries without a bio record
      if ((($rq->bio->bi_rw & 0x1) == IO_operation)  && ($rq->bio->bi_size == IO_size) )     
           requestTime[$rq] = gettimeofday_us()                                           
   } 
}


probe kernel.trace("block_rq_complete") {
   t = gettimeofday_us()
   s = requestTime[$rq]
   if (s > 0) {
       latencyTimes <<< (t-s)   # populates latency histogram
       delete requestTime[$rq]  # clears the timer for this $rq
   }
}


probe timer.sec(3) {
   printf("\n<begin record>\n")
   printf("timestamp, microsec, %d, %s\n",gettimeofday_us(),tz_ctime(gettimeofday_s()))
   printf("label, Latency of block I/O 8KB read requests measured with SystemTap\n")
   printf("latencyunit, microsec\n")
   printf("datasource, systemtap\n")
   if (@count(latencyTimes) > 0)
       println(@hist_log(latencyTimes))
   printf("\n<end record>\n")
}

